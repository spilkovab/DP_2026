'''
This is a script to merge folders generated by CVat into a correct structure
'''

import os 
import shutil
import yaml
from pathlib import Path
import random

# Paths
SOURCE_FOLDERS = ['dataset/palacak_01', 'dataset/palacak_02']
D_DIR = Path('dataset/data')
# Subsets
SUBSETS = {
    'train' : 'Train',
    'val' : 'Validation',
    'test' : 'Test'
}
# for convinience (please don't hit me for this, i am lazy and my brain is not working)
TRAIN_KEY = 'Train'
VAL_KEY = 'Validation'
TEST_KEY = 'Test'
# Possible image extensions
IMG_EXT = ['.jpg', '.png', '.jpeg', '.bmp']
# Split
VAL_SPLIT = 0.2
TEST_SPLIT = 0.1

def create_structure():
    ''' Creates a destination directory tree'''
    if D_DIR.exists():
        print(f"WARNING: Destination dir {D_DIR} already exists, merging into it.")

    for subset in set(SUBSETS.values()):
        (D_DIR / 'images' / subset).mkdir(parents=True, exist_ok=True)
        (D_DIR / 'labels' / subset).mkdir(parents=True, exist_ok=True)

def get_image_files(path):
    ''' Recursively finds images'''
    images = []
    if not path.exists():
        print(f"WARNING: No image path {path}")
        return images

    for ext in IMG_EXT:
        images.extend(list(path.glob(f'*{ext}')))
    
    return images

def move_files(image_list, dest_subset_pair, src_folder_name, src_lbl_root, txt_lists_dict):
    dest_subset_name_lower, dest_subset_name = dest_subset_pair
    for img_path in image_list:
        new_filename = f"{Path(src_folder_name).stem}_{img_path.name}"

        # set paths
        dest_img_path = D_DIR / 'images' / dest_subset_name / new_filename
        dest_lbl_path = D_DIR / 'labels' / dest_subset_name / (Path(new_filename).stem + ".txt")
        # Copy image
        shutil.copy2(img_path, dest_img_path)
        # Get old label path and copy label
        old_lbl_path = src_lbl_root / img_path.parent.name / (img_path.stem + '.txt')
        if old_lbl_path.exists():
            shutil.copy2(old_lbl_path, dest_lbl_path)

        rel_path = f"dataset/data/images/{dest_subset_name}/{new_filename}"
        txt_lists_dict[dest_subset_name_lower].append(rel_path)
        

def merge_data():
    create_structure()

    # Dicts to store lines for new txt files
    new_txt_lists = {dest: [] for dest in set(SUBSETS.keys())}

    # TODO: Maybe unnecessary
    first_yaml_content = None

    for src_name in SOURCE_FOLDERS:
        src_path = Path(src_name)
        print(f"-----Processing {src_name}-----")

        # Handle yaml ???
        yaml_file = src_path / 'data.yaml'
        if first_yaml_content is None and yaml_file.exists():
            with open(yaml_file, 'r') as f:
                first_yaml_content = yaml.safe_load(f)

        # Process images and labels
        src_img_root = src_path / 'images'
        src_lbl_root = src_path / 'labels'

        if not src_img_root.exists():
            print(f"WARNING: Skipping {src_img_root}, images folder not found.")
            continue

        # Make the split
        for fldr in src_img_root.iterdir():
            if fldr.is_dir():
                folder = fldr.name
                folder_name_lower = folder.lower()
                images = get_image_files(fldr)

                if 'train' in folder_name_lower:
                    total_imgs = len(images)
                    print(f"Found Train folder ({total_imgs} images)")

                    # shuffle randomly
                    random.shuffle(images)

                    # calculate total images for each split
                    val_count = int(total_imgs*VAL_SPLIT)
                    test_count = int(total_imgs*TEST_SPLIT)

                    # split the list
                    test_imgs = images[:test_count]
                    val_imgs = images[test_count : test_count+val_count]
                    train_imgs = images[test_count+val_count:]

                    # move files
                    move_files(test_imgs,list(SUBSETS.items())[2],src_name,src_lbl_root,new_txt_lists)
                    move_files(val_imgs,list(SUBSETS.items())[1],src_name,src_lbl_root,new_txt_lists)
                    move_files(train_imgs,list(SUBSETS.items())[0],src_name,src_lbl_root,new_txt_lists)

                    # Print check
                    print(f"Moved {len(train_imgs)} ---> 'Train'")
                    print(f"Moved {len(val_imgs)} ---> 'Validation'")
                    print(f"Moved {len(test_imgs)} ---> 'Test'")

                elif 'test' in folder_name_lower:
                    move_files(test_imgs, TEST_KEY, src_name, src_lbl_root, new_txt_lists)
                elif 'validation' in folder_name_lower:
                    move_files(val_imgs, VAL_KEY, src_name, src_lbl_root, new_txt_lists)


    print('----- Writing .txt files -----')
    for subset, lines in new_txt_lists.items():
        out_txt = D_DIR / f"{subset}.txt"
        with open(out_txt, 'w') as f:
            f.write('\n'.join(lines))
        print(f"Created {out_txt} with {len(lines)} entries")

    if first_yaml_content:
        print("--- Creating data.yaml ---")
        new_yaml = {
            'path': str(D_DIR.absolute()) + '/',
            'train': f"{list(SUBSETS.keys())[0]}.txt",
            'val': f"{list(SUBSETS.keys())[1]}.txt",
            'test': f"{list(SUBSETS.keys())[2]}.txt",
            'nc': first_yaml_content.get('nc', 5),
            'names': first_yaml_content.get('names', [])
        }
        
        with open(D_DIR / 'data.yaml', 'w') as f:
            yaml.dump(new_yaml, f, sort_keys=False)
        print("data.yaml created.")
        

if __name__ == "__main__":
    merge_data()
    print("DONE")